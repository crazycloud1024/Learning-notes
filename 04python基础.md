---
title: python基础
date: 2017-06-30 15:15:17
categories: python
tags: python
---
## 基础语法：

#### 一.冯诺依曼体系架构：

##### **五大部件：**

- CPU:包括运算器和控制器，CPU只和一件设备，内存打交道。

- 运算器：是完成各类算术运算，逻辑运算，数据传输等数据加工处理。数据是通过总线传输，总线则是使用电信号传输。

- 控制器：是用于控制程序的执行。

- 存储器memory：用于记忆程序和数据，例如内存（缺点：掉电易失数据）

- I 输入设备：将数据或者程序数据传输到计算机中，例如键盘，鼠标。

- O 输出设备：将数据或者程序的处理结果展示给用户，例如显示显示器，打印机。

- CPU有三级cache，寄存器，cpu临时要计算的数据存储在寄存器中，寄存器的频率和CPU几乎同频率的运算频率，多级缓存则逐级递减。

---

高级语言和低级语言之间需要一个转换的工具：编译器，解释器。

编译语言：把源代码转换成目标机器的CPU指令。例如：C，C++。
解释语言：解释后转换成字节码，运行在虚拟机上，解释器执行中间代码（bytecode）。例如：java，python，C#等语言。

#### 二.程序：算法 + 数据结构

- 数据是一切程序的核心

- 数据结构是数据在计算机中的类型和组织方式

- 算法是处理数据的方式，算法有优劣之分

- 算法运行时间并不以秒为单位，算法运行时间是从其增速的角度度量的。


##### python语言类型：
python是动态语言、强类型语言。
python中：**赋值即定义**，如果一个变量已经定义，赋值相当于重新定义。（动态语言的特性）

##### 语言的分类：
1. 静态编译语言：
    事先声明变量类型，类型不能再改变
    编译时检查
2. 动态编译语言：
    不用事先声明类型，随时可以赋值为其他类型
    编程时不知道是什么类型，很难推断。
3. 强类型语言：
    - 不同类型之间的操作，必须先强制类型转换为同一类型。例：print（'a'+1）
弱类型语言：
    - 不同类型之间操作，自动隐式转换，Javascript中console.log(1,+'a')

**重点**：什么是动态语言，什么是强类型语言，强弱怎么区分?
强弱是一个相对概念，用一个字符串加上一个数字就可判定。

---

##### python解释器：
- 官方Cpython：c语言开发，广泛的python解释器

- IPython：一个交互式，功能增强的Cpython

- PyPy：python语言写的python解释器，JIT（jist type）技术，动态编译python代码。（效率比cpython高）。

- Jython：python的源代码编译成java的字节码，跑在JVM上。

- IronPython：与Jython类似，运行在.net平台上的解释器，python代码被编译成.net的字节码。

##### 运算符优先级：
- 算术运算符 > 位运算符 > 身份运算符 > 成员运算符 > 逻辑运算符 > 赋值运算符
- 单目运算符 > 双目运算符

---

##### （JVM、PVM）内存管理：

1. 变量无须事先声明，也不需要指定类型（动态语言的特性）
2. python编程中一般无须关心变量的存亡，一般也不用关心内存的管理。
3. python使用引用技术记录所有对象的引用数：
    - 当对象引用数变为0，它就可以被垃圾回收（GC）的自动回收机制回收(不建议手动管理，会影响性能)
    - 计数增加：
        赋值给其他变量就增加引用计数，例如：x=3;y=x.
    - 计数减少：
        函数运行结束时，局部变量就会被自动销毁，对象引用计数减少
        变量被赋值给其他对象。例如：x=3,y=x（3的计数加一）,x=4（4的计数加一，3的计数减一）
    >**注意**：有关性能的时候，就要考虑变量的引用问题，切记尽量不要手动干预，但是该释放内存，还是尽量不释放内存，看需求。
   >**注意**：垃圾回收还有包括规整，即碎片整理 
- 共享引用：多个变量引用一个对象
    - ==是判断内容是否相等
    - is是判断是否指向同一内存空间，使用id来查看内存地址
    - 界限为256，256以下的整数已被python缓存
    - 判断一个东西有多少在引用： 
     ```py
     import sys
     sys.getrefcount(4)
     ```

##### False等价
布尔值，相当于bool(value)
- 空集合
- 空字符串
- 空字典
- 空列表
- 空元组
- none对象
- 0 


##### 列表、链表、队列、栈的区别
**重点**：
下列四者区别和特点
- 内存是线性编址的。
1. 列表list：
一个队列，一个排列整齐的队伍
列表中的个体称作元素，由若干个元素组成列表
元素可是是任意对象（数字，字符串，列表，元组，对象）
列表内元素有顺序，可以使用索引。
列表可以是一个可迭代对象
列表是可变的，连续的内存中的顺序结构，通过偏移量在查询（检索起来快）
“有顺序”“可索引”“可变”“可迭代”“线性结构”
尽量不要使用remove和insert，比较耗时

2. 链表：有序的在内存中分布散落，
查询比列表慢，插入比列表快

3. queue：队列，先进先出
不是为了遍历
4. stack：栈，后进先出

##### 元组修改
一般对于返回None的都意味着没有新的产生，就都是就地修改

元组：一个有序的元素组成的集合，不可变对象
元组 + 元组，元组*数字，返回一个新元组。并不是改变原先的元组
元组是只读的

字符串：是一个字面常量，**不可变**，可迭代

---



##### 运算符判断

|题|->|结果|
|:---|:---:|:---:|
|  6 or 2 > 1   | ->  |  6  |
|  0 or 5 < 4   | ->  | False|
|  5 < 4 or 3   | ->  |  3  |
|  2 > 1 or 6   | ->  |  True|
|  3 and 2 > 1  | ->  |  True|
|  0 and 3 > 1  | ->  |  0  |
|  2 > 1 and 3  | ->  |  3  |
|  3 > 1and 0   | ->  |  0  |
|print(1 or 2)  | ->  |  1  |
|print(0 or 100)| ->  |  100|
|print(1 and 2) |  -> |  2  |
|print（bool(2)）| ->  |  True|
|print(bool(-2)) | ->  |  True|
|print(bool(0)   | ->  | False|

**方法：**
- **x or y x为 (True) 非零，则返回x**
- x and y x (True)非零，则返回y
- 非零转换成bool   True     
- 0转换成bool是False     

---

>拓展：while 1 的效率要比 while True高，因为Ture要先转换成1，然后再转化成二进制
    网络传输，big:大端模式，
    低字节放在高地址上就是大端模式
    高字节放到低地址上就是小端模式
    Windows小端模式 mac大端模式

python上下文：使用with方法不用每次都手动关闭文件
```py
with open("file.xxx") as f:
    for line in f.readlines():
        print(line)
```
使用二进制写文件可以使用一个模块
写：`pickle.dump(word,file)`
读：`pickle.load(file)`

---

##### 封装和解构：
1. 封装：
 将多个值使用逗号分隔，结合在一起
 本质上返回了一个元组，只是省略了小括号
 t1 = (1,2) # 定义为元组
 t2 = 1,2  #将1，2封装成元组

2. 解构
把右边的元素解开，并顺序的赋给其他变量
左边接纳的变量数要和右边解开的元素个数一致
使用\*变量名接收，但不能单独使用，被\*变量名收集后组成一个列表
例如： head,*mid,tail = "abcdefghijklmnopqrstuvwxyz"

例：
```
temp = a
a = b
b = temp
等价于
a , b = b , a
```
等号右边使用了封装，而左边使用了解构

##### set和线性结构
- 线性结构的查询时间复杂度是O(n)，即随着数据规模的增大而增大
- set、dict等结构，内部使用hash值作为key，时间复杂度为O(1),查询时间与数据规模无关。
- set的元素要求必须可哈希
    ​    可变的数据结构不可哈希
    ​    元素不可索引
    ​    set可以迭代
- 线性结构：
    - 可迭代 for ... in
    - len()可以获取长度
    - 通过下标可访问
    - 可以切片
- 包括：列表、元组、字符串、bytes、bytearray
  不可变对象：元组、字符串、bytes
- 可hash对象：
  数值型：int、float、complex
  布尔型：True、False
  字符串：string、bytes
  tuple，None
  以上都为不可变类型
- 可变类型：list，dict，bytearray
- 可迭代对象
  - 能够通过迭代一次次返回不同的元素的对象。
  - 所谓相同，不是指值是否相同，而是元素在容器中是否是同一个，例如列表中值可以重复的，['a', 'a']，虽然这个列表有2个元素，值一样，但是两个'a'是不同的元素
  - 可以迭代，但是未必有序，未必可索引
  - 可迭代对象有：list、tuple、string、bytes、bytearray、range、set、dict、生成器等
  - 可以使用成员操作符in、not in，in本质上就是在遍历对象

---

字典的遍历和移除：不能直接遍历删除字典，要使用一个容器记录一个这个字典的key，然后通过遍历key来从字典中删除。

权限判定可以将弄成集合加载到内存中进行集合计算，速度要比在数据库中操作对比快得多。比如说微博的redis

- OrderedDict
  有序字典可以记录元素插入的顺序，打印的时候也是按照这个顺序输出打印
  3.6版本的Python的字典就是记录key插入的顺序（IPython不一定有效果）

- 应用场景：
    - 假如使用字典记录了N个产品，这些产品使用ID由小到大加入到字典中

    - 除了使用字典检索的遍历，有时候需要取出ID，但是希望是按照输入的顺序，因为输入顺序是有序的

    - 否则还需要重新把遍历到的值排序

------

光盘、磁盘都是随机访问的

